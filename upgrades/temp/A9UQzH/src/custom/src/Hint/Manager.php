<?php
/*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
namespace Sugarcrm\Sugarcrm\custom\Hint;

use Psr\Log\LoggerAwareInterface;
use Psr\Log\LoggerAwareTrait;
use Sugarcrm\Sugarcrm\custom\Hint\Http\Client;
use Sugarcrm\Sugarcrm\custom\Hint\Logger\Logger as HintLogger;

/**
 * Class Manager - this is singleton used to access all Hint services
 */
class Manager implements LoggerAwareInterface
{
    use LoggerAwareTrait;

    //
    //  Class constants
    //
    /**
     * @var string Configuration key for endpoint.
     */
    const CONFIG_KEY_SERVICE_URL = 'service-url';

    /**
     * @var string ISS service URL
     */
    const ISS_SERVICE_URL = 'hint-iss-service-url';
    /**
     * @var string notifications service URL
     */
    const NOTIFICATIONS_SERVICE_URL = 'hint-notifications-service-url';

    /**
     * @var string Configuration key for Stage2 obfuscation salt. This salt value is used whenever
     * there is a need to uniquelly (accross all SugarCRM client instances) obfuscate a datum
     * (e.g. user's analytic's ID) It is both random and unknown to Stage2 service to prevent
     * reversing obfuscation.
     */
    const CONFIG_KEY_OBFUSCATION_SALT = 'obfuscation-salt';

    /**
     * @var string IS module name.
     */
    const MODULE = 'Stage2';

    /**
     * @var string IS platform.
     */
    const PLATFORM = 'base';

    /**
     * @var string Key for access token in Stage2 and Notifications Service authentication response.
     */
    const KEY_ACCESS_TOKEN = 'token';

    const KEY_TIME_TO_LIVE_MILLISECONDS = 'ttlMs';

    const KEY_MAX_REQUESTS_PER_SECOND = 'maxReqPerSec';


    /**
     * @var string Key for subscription type in Stage2 authentication response.
     */
    const SUBSCRIPTION_TYPE = 'subscriptionType';

    /**
     * Get instance.
     */
    public static function instance()
    {
        //  Singleton instance.
        static $instance = null;

        if (is_null($instance)) {
            $instance = new static();
        }

        $instance->setLogger(new HintLogger());
        $instance->initialize();

        return $instance;
    }

    public $serviceUrl = null;
    public $issServiceUrl = null;
    public $notificationsServiceUrl = null;
    public $instanceId = null;
    public $licenseKey = null;
    public $sugarVersion = null;

    /**
     * Initialize internal variables.
     */
    public function initialize()
    {
        $this->logger->info('Initializing shared instance of Hint Manager.');

        //  Load configuration from the database.
        $dbConfig = $this->loadConfig();

        //  Salt is not included in the optional client config file as it has to be both unique
        //  accross all SugarCRM client instances *and* remain unknown to our service (otherwise
        //  obfuscation could be reversed). Thus the salt is always generated by the SugarCRM
        //  instance itself.
        //  Always initialize the salt as it may be even used without the rest of the config.
        if (array_key_exists(static::CONFIG_KEY_OBFUSCATION_SALT, $dbConfig)) {
            $this->obfuscationSalt = $dbConfig[static::CONFIG_KEY_OBFUSCATION_SALT];
        } else {
            $this->obfuscationSalt = uniqid();
            \BeanFactory::getBean('Administration')->saveSetting(
                static::MODULE,
                static::CONFIG_KEY_OBFUSCATION_SALT,
                $this->obfuscationSalt,
                static::PLATFORM
            );
        }

        //  Also try to load optional client config file which may be included with
        //  some distributions. When it is, the configuration from the database
        //  still takes precedence.
        $buildConfig = include 'custom/Stage2/Stage2ClientBuildConfig.php';

        //  Read client options and create the client.
        $serviceUrl = static::readOptionFromConfigurations(
            $dbConfig, $buildConfig, static::CONFIG_KEY_SERVICE_URL);
        if (is_null($serviceUrl) || empty($serviceUrl)) {
            $this->logger->alert('Missing ' . static::CONFIG_KEY_SERVICE_URL . ' Stage2 config param.');
            return;
        }

        $this->serviceUrl = $serviceUrl;

        $issServiceUrl = static::readOptionFromConfigurations(
            $dbConfig, $buildConfig, static::ISS_SERVICE_URL);
        if (empty($issServiceUrl)) {
            $this->logger->alert('Missing ' . static::ISS_SERVICE_URL . ' Stage2 config param.');
            return;
        }

        $this->issServiceUrl = $issServiceUrl;

        $notificationsServiceUrl = static::readOptionFromConfigurations(
            $dbConfig, $buildConfig, static::NOTIFICATIONS_SERVICE_URL);
        if (empty($notificationsServiceUrl)) {
            $this->logger->alert('Missing ' . static::NOTIFICATIONS_SERVICE_URL . ' Stage2 config param.');
            return;
        }

        $this->notificationsServiceUrl = $notificationsServiceUrl;

        // Read instance ID and license key from system info.
        $systemInfo = \SugarSystemInfo::getInstance();
        $this->instanceId = $systemInfo->getApplicationKeyInfo()['application_key'];
        $this->licenseKey = $systemInfo->getLicenseKey();
        $this->sugarVersion = $systemInfo->getAppInfo()['sugar_version'];

        $this->logger->info('Shared instance of Hint Manager initialized.');
    }

    /**
     * Get a new access token.
     *
     * @return array (string indexed)
     * @throws \SugarApiException
     * @throws \SugarApiExceptionError
     * @throws \SugarApiExceptionInvalidGrant
     * @throws \SugarApiExceptionNotAuthorized
     * @throws \SugarApiExceptionNotFound
     */
    public function getNewAccessToken()
    {
        $config = \SugarConfig::getInstance();

        $stage2client = new Client($this->serviceUrl);

        $body = [
            'companyId' => $this->licenseKey,
            'siteURL' => $config->get('site_url'),
            'uniqueKey' => $config->get('unique_key'),
        ];

        //  Obtain access token for Stage2.
        $response = $stage2client->newToken($body);
        if (empty($response[static::KEY_ACCESS_TOKEN])) {
            throw new \SugarApiException('Bad response from Stage2 authorize');
        }

        $tokenResponse = ['accessToken' => $response[static::KEY_ACCESS_TOKEN]];
        // older servers won't send the subscription type, so be check before using
        if (isset($response[static::SUBSCRIPTION_TYPE])) {
            $tokenResponse['subscriptionType'] = $response[static::SUBSCRIPTION_TYPE];
        }
        return $tokenResponse;
    }

    /**
     * Get a new notifications service access token.
     *
     * @return array (string indexed)
     * @throws \SugarApiException
     * @throws \SugarApiExceptionError
     * @throws \SugarApiExceptionInvalidGrant
     * @throws \SugarApiExceptionNotAuthorized
     * @throws \SugarApiExceptionNotFound
     */
    public function createNotificationsServiceAccessToken()
    {
        global $current_user;

        $config = \SugarConfig::getInstance();
        $systemInfo = \SugarSystemInfo::getInstance();

        if (empty($this->instanceId) || empty($this->licenseKey)) {
            $this->logger->alert('Missing Notifications Service client ID/secret');
            throw new \SugarApiExceptionNotAuthorized('Bad configuration for Notifications Service');
        }

        $stage2client = new Client($this->notificationsServiceUrl);
        $body = [
            'userId' => $current_user->id,
            'companyId' => $this->licenseKey,
            'sugarVersion' => $systemInfo->getAppInfo()['sugar_version'],
            'siteURL' => $config->get('site_url', ''),
            'uniqueKey' => $config->get('unique_key', ''),
        ];

        //  Obtain access token for Stage2.
        $response = $stage2client->createNotificationsServiceToken($body);
        if (empty($response[static::KEY_ACCESS_TOKEN])) {
            throw new \SugarApiException('Bad response from Notifications Service authorize');
        }

        $tokenResponse = [
            'accessToken' => $response[static::KEY_ACCESS_TOKEN],
            'ttlMs' => $response[static::KEY_TIME_TO_LIVE_MILLISECONDS],
            'maxReqPerSec' => $response[static::KEY_MAX_REQUESTS_PER_SECOND]
        ];
        return $tokenResponse;
    }

    public function registerToCompanyID()
    {
        $config = \SugarConfig::getInstance();

        if (empty($this->instanceId) || empty($this->licenseKey)) {
            $this->logger->alert('Missing Notifications Service client ID/secret');
            throw new \SugarApiExceptionNotAuthorized('Bad configuration for Notifications Service');
        }

        $stage2client = new Client($this->serviceUrl);

        $body = [
            'companyId' => $this->licenseKey,
            'siteURL' => $config->get('site_url'),
            'uniqueKey' => $config->get('unique_key'),
        ];
        // Obtain access token for Stage2.
        $response = $stage2client->registerToCompanyIdentity($body);

        $tokenResponse = [
            'status' => $response
        ];

        return $tokenResponse;
    }

    public function registerToConfigBean($accessToken, $configDataBeanData)
    {
        $stage2client = new Client($this->serviceUrl);
        $body = [
            'data' => $configDataBeanData,
        ];

        $response = $stage2client->registerToConfigIdentity($accessToken['accessToken'], $body);

        $tokenResponse = [
            'status' => $response
        ];

        return $tokenResponse;
    }

    /**
     * Return persisted configuration options for the given key.
     * If there are none, empty array is returned.
     *
     * @return array Options loaded from the configuration.
     */
    public static function loadConfig()
    {
        return \BeanFactory::getBean('Administration')->getConfigForModule(
            static::MODULE,
            static::PLATFORM,
            true/*Always get clean copy to avoid dirty reads*/);
    }

    public function getCurrentUserAnalyticsId()
    {
        return sha1($this->obfuscationSalt . $GLOBALS['current_user']->id);
    }

    public function getISPs()
    {
        $uploadFile = new \UploadFile();
        $uploadFile->temp_file_location = 'custom/Stage2/isp-list.js';
        $content = $uploadFile->get_file_contents();
        return $content;
    }

    public static function getVAPIDPublicKey()
    {
        return 'BCoRPLoIDJTOwAJNbAtdhuScQfJMCveFRv-f-9G6kXtW5BXNEc2DJJmIcCCQq70MnGZFiUCqjYH39Ub-XE4ayMY';
    }

    private static function readOptionFromConfigurations($dbConfig, $buildConfig, $option)
    {
        //  Database configuration takes precedence over build client configuration
        //  as we will never instruct administrators to change their local files but
        //  rather configuration in the database.
        if (array_key_exists($option, $dbConfig)) {
            return $dbConfig[$option];
        } else if (!is_null($buildConfig) && array_key_exists($option, $buildConfig)) {
            return $buildConfig[$option];
        } else {
            return null;
        }
    }
}
